This was taken from ISO/IEC 9899:201x n1516.  I've moved syntactic properties and things related to cpp to bottom, along with cases that are partially tested.  Undefinedness pertaining to libraries is in undefinedLib.txt

001	A "shall" or "shall not" requirement that appears outside of a constraint is violated (clause 4). 
005	The execution of a program contains a data race (5.1.2.4). 
006	A character not in the basic source character set is encountered in a source file, except in an identifier, a character constant, a string literal, a header name, a comment, or a preprocessing token that is never converted to a token (5.2.1). 
007	An identifier, comment, string literal, character constant, or header name contains an invalid multibyte character or does not begin and end in the initial shift state (5.2.1.2). 
013	A trap representation is produced by a side effect that modifies any part of the object using an lvalue expression that does not have character type (6.2.6.1). 
014	The operands to certain operators are such that they could produce a negative zero result, but the implementation does not support negative zeros (6.2.6.2). 
016	A program requires the formation of a composite type from a variable length array type whose size is specified by an expression that is not evaluated (6.2.7). 
018	Demotion of one real floating type to another produces a value outside the range that can be represented (6.3.1.5). 
019	An lvalue does not designate an object when evaluated (6.3.2.1). 
020	A non-array lvalue with an incomplete type is used in a context that requires the value of the designated object (6.3.2.1). 
021	An lvalue designating an object of automatic storage duration that could have been declared with the register storage class is used in a context that requires the value of the designated object, but the object is uninitialized. (6.3.2.1). 
024	Conversion of a pointer to an integer type produces a value outside the range that can be represented (6.3.2.3). 
025	Conversion between two pointer types produces a result that is incorrectly aligned (6.3.2.3). 
026	A pointer is used to call a function whose type is not compatible with the referenced type (6.3.2.3). 
031	Two identifiers differ only in nonsignificant characters (6.4.2.1). 
035	A side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object (6.5). 
036	An exceptional condition occurs during the evaluation of an expression (6.5). 
037	An object has its stored value accessed other than by an lvalue of an allowable type (6.5). 
041	A function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function (6.5.2.2). 
042	A member of an _Atomic-qualified structure or union is accessed (6.5.2.3). 
050	The result of subtracting two pointers is not representable in an object of type ptrdiff_t (6.5.6). 
051	An expression is shifted by a negative number or by an amount greater than or equal to the width of the promoted expression (6.5.7). 
052	An expression having signed promoted type is left-shifted and either the value of the expression is negative or the result of shifting would be not be representable in the promoted type (6.5.7). 
053	Pointers that do not point to the same aggregate or union (nor just beyond the same array object) are compared using relational operators (6.5.8). 
054	An object is assigned to an inexactly overlapping object or to an exactly overlapping object with incompatible type (6.5.16.1). 
055	An expression that is required to be an integer constant expression does not have an integer type; has operands that are not integer constants, enumeration constants, character constants, sizeof expressions whose results are integer constants, or immediately-cast floating constants; or contains casts (outside operands to sizeof operators) other than conversions of arithmetic types to integer types (6.6). 
056	A constant expression in an initializer is not, or does not evaluate to, one of the following: an arithmetic constant expression, a null pointer constant, an address constant, or an address constant for a complete object type plus or minus an integer constant expression (6.6). 
057	An arithmetic constant expression does not have arithmetic type; has operands that are not integer constants, floating constants, enumeration constants, character constants, or sizeof expressions; or contains casts (outside operands to sizeof operators) other than conversions of arithmetic types to arithmetic types (6.6). 
058	The value of an object is accessed by an array-subscript [], member-access . or ->, address &, or indirection * operator or a pointer cast in creating an address constant (6.6). 
059	An identifier for an object is declared with no linkage and the type of the object is incomplete after its declarator, or after its init-declarator if it has an initializer (6.7). 
062	An attempt is made to access, or generate a pointer to just past, a flexible array member of a structure when the referenced object provides no elements for that array (6.7.2.1). 
063	When the complete type is needed, an incomplete structure or union type is not completed in the same scope by another declaration of the tag that defines the content (6.7.2.3). 
064	An attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type (6.7.3). 
065	An attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type (6.7.3). 
066	An attempt is made to refer to an object defined with an _Atomic-qualified type through use of an lvalue with non-_Atomic-qualified type (6.7.3). 
068	Two qualified types that are required to be compatible do not have the identically qualified version of a compatible type (6.7.3). 
069	An object which has been modified is accessed through a restrict-qualified pointer to a const-qualified type, or through a restrict-qualified pointer and another pointer that are not both based on the same object (6.7.3.1). 
070	A restrict-qualified pointer is assigned a value based on another restricted pointer whose associated block neither began execution before the block associated with this pointer, nor ended before the assignment (6.7.3.1). 
071	A function with external linkage is declared with an inline function specifier, but is not also defined in the same translation unit (6.7.4). 
072	A function declared with a _Noreturn function specifier returns to its caller (6.7.4). 
073	The definition of an object has an alignment specifier and another declaration of that object has a different alignment specifier (6.7.5). 
074	Declarations of an object in different translation units have different alignment specifiers (6.7.5). 
075	Two pointer types that are required to be compatible are not identically qualified, or are not pointers to compatible types (6.7.6.1). 
076	The size expression in an array declaration is not a constant expression and evaluates at program execution time to a nonpositive value (6.7.6.2). 
077	In a context requiring two array types to be compatible, they do not have compatible element types, or their size specifiers evaluate to unequal values (6.7.6.2). 
078	A declaration of an array parameter includes the keyword static within the [ and ] and the corresponding argument does not provide access to the first element of an array with at least the specified number of elements (6.7.6.3). 
079	A storage-class specifier or type qualifier modifies the keyword void as a function parameter type list (6.7.6.3). 
080	In a context requiring two function types to be compatible, they do not have compatible return types, or their parameters disagree in use of the ellipsis terminator or the number and type of parameters (after default argument promotion, when there is no parameter type list or when one type is specified by a function definition with an identifier list) (6.7.6.3). 
081	The value of an unnamed member of a structure or union is used (6.7.9). 
082	The initializer for a scalar is neither a single expression nor a single expression enclosed in braces (6.7.9). 
083	The initializer for a structure or union object that has automatic storage duration is neither an initializer list nor a single expression that has compatible structure or union type (6.7.9). 
084	The initializer for an aggregate or union, other than an array initialized by a string literal, is not a brace-enclosed list of initializers for its elements or members (6.7.9). 
085	An identifier with external linkage is used, but in the program there does not exist exactly one external definition for the identifier, or the identifier is not used and there exist multiple external definitions for the identifier (6.9). 
086	A function definition includes an identifier list, but the types of the parameters are not declared in a following declaration list (6.9.1). 
087	An adjusted parameter type in a function definition is not a complete object type (6.9.1). 
088	A function that accepts a variable number of arguments is defined without a parameter type list that ends with the ellipsis notation (6.9.1). 
090	An identifier for an object with internal linkage and an incomplete type is declared with a tentative definition (6.9.2). 




Syntactic 
002	A nonempty source file does not end in a new-line character which is not immediately preceded by a backslash character or ends in a partial preprocessing token or comment (5.1.1.2). 
003	Token concatenation produces a character sequence matching the syntax of a universal character name (5.1.1.2). 
027	An unmatched ' or " character is encountered on a logical source line during tokenization (6.4). 
028	A reserved keyword token is used in translation phase 7 or 8 for some purpose other than as a keyword (6.4.1). 
029	A universal character name in an identifier does not designate a character whose encoding falls into one of the specified ranges (6.4.2.1). 
030	The initial character of an identifier is a universal character name designating a digit (6.4.2.1). 
034	The characters ', \, ", //, or /* occur in the sequence between the < and > delimiters, or the characters ', \, //, or /* occur in the sequence between the " delimiters, in a header name preprocessing token (6.4.7). 

Macros
091	The token defined is generated during the expansion of a #if or #elif preprocessing directive, or the use of the defined unary operator does not match one of the two specified forms prior to macro replacement (6.11). 
092	The #include preprocessing directive that results after expansion does not match one of the two header name forms (6.12). 
093	The character sequence in an #include preprocessing directive does not start with a letter (6.12). 
094	There are sequences of preprocessing tokens within the list of macro arguments that would otherwise act as preprocessing directives (6.13). 
095	The result of the preprocessing operator # is not a valid character string literal (6.13.2). 
096	The result of the preprocessing operator ## is not a valid preprocessing token (6.13.3). 
097	The #line preprocessing directive that results after expansion does not match one of the two well-defined forms, or its digit sequence specifies zero or a number greater than 2147483647 (6.14). 
098	A non-STDC #pragma preprocessing directive that is documented as causing translation failure or some other form of undefined behavior is encountered (6.16). 
099	A #pragma STDC preprocessing directive does not match one of the well-defined forms (6.16). 
100	The name of a predefined macro, or the identifier defined, is the subject of a #define or #undef preprocessing directive (6.18). 



Partially Tested
004	A program in a hosted environment does not define a function named main using one of the specified forms (5.1.2.2.1). 
008	The same identifier has both internal and external linkage in the same translation unit (6.2.2). 
009	An object is referred to outside of its lifetime (6.2.4). 
010	The value of a pointer to an object whose lifetime has ended is used (6.2.4). 
Remark: I'm not sure how you could do 009 without doing 010.
011	The value of an object with automatic storage duration is used while it is indeterminate (6.2.4, 6.7.9, 6.8). 
012	A trap representation is read by an lvalue expression that does not have character type (6.2.6.1). 
015	Two declarations of the same object or function specify types that are not compatible (6.2.7). 
017	Conversion to or from an integer type produces a value outside the range that can be represented (6.3.1.4). 
022	An lvalue having array type is converted to a pointer to the initial element of the array, and the array object has register storage class (6.3.2.1). 
023	An attempt is made to use the value of a void expression, or an implicit or explicit conversion (except to void) is applied to a void expression (6.3.2.2). 
032	The identifier __func__ is explicitly declared (6.4.2.2). 
033	The program attempts to modify a string literal (6.4.5). 
038	For a call to a function without a function prototype in scope, the number of arguments does not equal the number of parameters (6.5.2.2). 
039	For call to a function without a function prototype in scope where the function is defined with a function prototype, either the prototype ends with an ellipsis or the types of the arguments after promotion are not compatible with the types of the parameters (6.5.2.2). 
040	For a call to a function without a function prototype in scope where the function is not defined with a function prototype, the types of the arguments after promotion are not compatible with those of the parameters after promotion (with certain exceptions) (6.5.2.2). 
043	The operand of the unary * operator has an invalid value (6.5.3.2). 
044	A pointer is converted to other than an integer or pointer type (6.5.4). 
045	The value of the second operand of the / or % operator is zero (6.5.5). 
046	Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that does not point into, or just beyond, the same array object (6.5.6). 
047	Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that points just beyond the array object and is used as the operand of a unary * operator that is evaluated (6.5.6). 
048	Pointers that do not point into, or just beyond, the same array object are subtracted (6.5.6). 
049	An array subscript is out of range, even if an object is apparently accessible with the given subscript (as in the lvalue expression a[1][7] given the declaration int a[4][5]) (6.5.6). 
060	A function is declared at block scope with an explicit storage-class specifier other than extern (6.7.1). 
061	A structure or union is defined as containing no named members, no anonymous structures, and no anonymous unions (6.7.2.1). 
067	The specification of a function type includes any type qualifiers (6.7.3). 
089	The } that terminates a function is reached, and the value of the function call is used by the caller (6.9.1). 

