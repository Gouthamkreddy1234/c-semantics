#!/usr/bin/env perl
use strict;
use warnings;

use v5.10;
use Cwd qw(abs_path getcwd);
use File::Basename qw(basename dirname fileparse);
use lib dirname(__FILE__);

use File::Copy qw(move);
use File::Path qw(rmtree);
use File::Spec::Functions qw(rel2abs catfile);
use MIME::Base64 qw(encode_base64);
use String::Escape qw(quote backslash);
use UUID::Tiny qw(:std);

use RV_Kcc::Files qw(profileDir distDir tempFile tempDir IS_CYGWIN);
use RV_Kcc::Opts qw(
      getopts arg classify
      cppArgs suppressions ifdefs ldArgs nativeObjFiles srcFiles objFiles trampolineFiles
      RVMAIN BASE_LIBS MAGIC
);
use RV_Kcc::Shell qw(shell checkError setShellDebugFile saveArgv);

# Here we trap control-c (and others) so we can clean up when that happens.
$SIG{'ABRT'} = 'interruptHandler';
$SIG{'TERM'} = 'interruptHandler';
$SIG{'QUIT'} = 'interruptHandler';
$SIG{'SEGV'} = 'interruptHandler';
$SIG{'HUP' } = 'interruptHandler';
$SIG{'TRAP'} = 'interruptHandler';
$SIG{'STOP'} = 'interruptHandler';
$SIG{'INT'} = 'interruptHandler'; # Handle control-c.

use constant KRUN         => IS_CYGWIN? 'krun.bat' : 'krun';
use constant PRINTF       => IS_CYGWIN? 'printf %%s' : 'printf %s';
use constant QUOTE_INT    => IS_CYGWIN? backslash("\"Int\"") : "\"Int\"";
use constant QUOTE_STRING => IS_CYGWIN? backslash("\"String\"") : "\"String\"";

exit main();

sub main {
      saveArgv();

      foreach (@ARGV) {
            # Clean entries: remove spaces, tabs and newlines
            $_ =~ tr/ \t\n/\0\0\0/;
      }

      getopts() or error("Failed to parse the command line.\n");

      my $noLicense = defined(arg('--no-license-message'))
            || defined($ENV{'KCC_NO_LICENSE_MESSAGE'});

      my $msg = '';

      my $heapSize = "1G";
      if (arg('-Xmx')) {
            $heapSize = arg('-Xmx');
      }
      # Set heap and stack size of krun
      $ENV{K_OPTS} = "-Xmx$heapSize";
      if (arg('-d')) {
            $ENV{OCAMLRUNPARAM} = "s=32M,b,l=8M";
            $File::Temp::KEEP_ALL = 1;
      } else {
            $ENV{OCAMLRUNPARAM} = "s=32M,l=8M";
      }

      if (!srcFiles() && !objFiles()) {
            error("no input files found.\n");
      }

      if (arg('-E') || arg('-M') || arg('-MM')) {
            my $oval = arg('-o');
            if ($oval) {
                  if (scalar srcFiles() > 2) {
                        error("cannot specify -o with -c or -E with multiple files.\n");
                  }
            } else {
                  $oval = '-';
            }
            return preprocess($oval, '/dev/null', (srcFiles())[0], (srcFiles())[1]);
      }

      if (arg('-c')) {
            my $oval = arg('-o');
            if ($oval) {
                  if (scalar srcFiles() > 2) {
                        error("cannot specify -o with -c or -E with multiple files.\n");
                  }
                  if (!$noLicense && $msg ne '') {
                        printf "%s\n", $msg;
                  }
                  my $result = tempFile('compile');
                  compile($result, (srcFiles())[0], (srcFiles())[1]);
                  move($result, $oval);
            } else {
                  if (!$noLicense && $msg ne '') {
                        printf "%s\n", $msg;
                  }
                  for (my $i = 0; $i < (scalar srcFiles() - 1); $i += 2) {
                        $oval = basename((srcFiles())[$i], ".c", ".cc", ".cp", ".cxx", ".cpp", ".CPP", ".c++", ".C", ".h", ".hh", ".hp", ".hxx", ".hpp", ".HPP", ".h++", ".H", ".tcc") . ".o";
                        my $result = tempFile('compile');
                        compile($result, (srcFiles())[$i], (srcFiles())[$i+1]);
                        move($result, $oval);
                  }
            }
            return 0;
      }

      if (arg('-shared')) {
            my $tramp = mergeObjs(srcFiles());

            my $accum = tempFile('accum');
            shell(getKRunCommand($accum, [objFiles()], undef, 0, 'c++', undef, undef))->verbose()->run();

            my $obj = tempFile('merge');
            shell('ld', '-r', '-o', $obj, nativeObjFiles())->run();
            shell(distDir('merge-kcc-obj'), $obj, $accum, $tramp, arg('-o') || 'a.out')->run();
            return 0;
      }

      if (!arg('-nodefaultlibs')) {
            classify(profileDir('lib', 'libc.so'), 'none');
            if (arg('-Xk++')) {
                  classify(profileDir('lib', 'libstdc++.so'), 'none');
            }
      }

      # Reduce our remaining source files to object files
      my $tramp = mergeObjs(srcFiles());

      my $oval = arg('-o') || 'a.out';

      my $programConfFile = tempFile('conf');

      if (!$noLicense && $msg ne '') {
            printf "%s\n", $msg;
      }

      # At this point, we have 0 source files and 1 object file left for
      # the final calls to krun.
      shell(getKRunCommand($programConfFile, [objFiles()], undef, 1, 'c++', undef, undef))->verbose()->run();

      # add space to end of args with () so that batch scripts work on windows
      my @options = initOptions();
      if (arg('-flint') || arg('-Wlint')) {
            my $heapSize;
            if (arg('-fheap-size=')) {
                  $heapSize = shell("echo " . arg('-fheap-size=') . " | sed -e 's/[Tt]/kg/i;s/[Gg]/km/i;s/[Mm]/kk/i;s/k/*1024/ig' | bc")->stdout()->run();
                  chop($heapSize);
            } else {
                  $heapSize = 1024 * 1024 * 1024;
            }
            my $heapSizeInt = $heapSize;
            $heapSize = quote(backslash($heapSize));
            if (IS_CYGWIN) {
                  $heapSize = backslash($heapSize);
            }
            my $stackSize;
            if (arg('-fstack-size=')) {
                  $stackSize = shell("echo " . arg('-fstack-size=') . " | sed -e 's/[Tt]/kg/i;s/[Gg]/km/i;s/[Mm]/kk/i;s/k/*1024/ig' | bc")->stdout()->run();
                  chop($stackSize);
            } else {
                  $stackSize = shell('ulimit -s')->stdout()->run();
                  chop($stackSize);
                  if ($stackSize eq 'unlimited') {
                        $stackSize = $heapSizeInt;
                  } else {
                        $stackSize = $stackSize * 1024; # result was in kb
                  }
            }
            $stackSize = quote(backslash($stackSize));
            if (IS_CYGWIN) {
                  $stackSize = backslash($stackSize);
            }
            my $int = QUOTE_INT;
            push(@options, "`Heap`(#token($heapSize, $int))");
            push(@options, "`Stack`(#token($stackSize, $int))");
      }

      if (arg('-e')) {
            my $entry = quote(backslash(quote(arg('-e'))));
            my $string = QUOTE_STRING;
            push(@options, "`EntryPoint`(#token($entry, $string))");
      }

      my $opts = makeSet(@options);
      my $useCompile = -e profileDir('c11-cpp14-kompiled', 'c11-cpp14-kompiled', 'execution_partial.o');

      if (arg('-frunner-script') || !$useCompile) {
            open(FILE, $programConfFile) or error("Couldn't open file: $!\n");
            my $programConf = join("", <FILE>);
            close(FILE);
            $programConf = encode_base64($programConf);
            open(FILE, distDir('program-runner')) or error("Couldn't open file: $!\n");
            my $template = join("", <FILE>);
            close(FILE);

            my $profDir = profileDir();
            $template =~ s?EXTERN_SCRIPTS_DIR?$profDir?g;
            $template =~ s?EXTERN_HEAP_SIZE?$heapSize?g;

            open(my $programRunner, '>', $oval) or error("Couldn't open file: $!\n");
            print $programRunner "$template\n";
            print $programRunner "sub linkedProgram {\nreturn <<'PROGRAMCONF';\n$programConf\nPROGRAMCONF\n}\n";
            print $programRunner "sub nativeLibraries {\n return '" . join(' ', BASE_LIBS) . "';\n}\n";

            if (nativeObjFiles()) {
                  my $obj = tempFile('obj');
                  shell('ld', '-r', '-o', $obj, nativeObjFiles())->run();
                  open(FILE, $obj) or error("Couldn't open file: $!\n");
                  my $programObj = join("", <FILE>);
                  close(FILE);
                  $programObj = encode_base64($programObj);
                  print $programRunner "sub nativeObjFile {\nreturn <<'PROGRAMOBJ';\n$programObj\nPROGRAMOBJ\n}\n";
            } else {
                  print $programRunner "sub nativeObjFile {\n return undef;\n}\n";
            }

            my $encodedJsonAsPerlString = quote(backslash(getRVErrorJson()));
            print $programRunner "sub getJson {\n return $encodedJsonAsPerlString;\n}\n";

            my $encodedOptsAsPerlString = quote(backslash($opts));
            print $programRunner "sub getOptions {\n return $encodedOptsAsPerlString;\n}\n";

            close($programRunner);
            my $numFilesChanged = chmod(0755, $oval);

            ($numFilesChanged == 1)
                  or error("Call to chmod $oval failed.\n");
      } else {
            my $dir = profileDir('c11-cpp14-kompiled', 'c11-cpp14-kompiled');
            my $tempDir = tempDir('res');
            my ($rvErrorJson, $string) = (getRVErrorJson(), QUOTE_STRING);
            setShellDebugFile($programConfFile, 1);
            shell(catfile($dir, 'marshalvalue'),
                        catfile($dir, 'realdef.cma'),
                        '-c', 'ARGV', '`#argv`(.KList) ', 'text',
                        '-c', 'OPTIONS', $opts, 'text',
                        '-c', 'JSON', "#token($rvErrorJson, $string)", 'text',
                        '--output-file', catfile($tempDir, 'kore_term')
                 )->run();
            shell(catfile($dir, 'marshalvalue'),
                        catfile($dir, 'realdef.cma'), '-s', # -s before -c
                        '-c', 'PGM', $programConfFile, 'binaryfile',
                        '--output-file', catfile($tempDir, 'marshal_term')
                 )->run();

            open(my $pluginPath, '>', catfile($tempDir, "plugin_path")) or error("Couldn't open file: $!\n");
            print $pluginPath catfile($dir, 'realdef.cma');
            close($pluginPath);

            my $compiler;
            if (arg('-Xk++')) {
                  $compiler = 'g++';
            } else {
                  $compiler = 'gcc';
            }

            if (arg('-fnative-binary')) {
                  my $dir = profileDir('native-server');
                  shell("cat '$tramp' | awk -F '\t' '{if (\$1!=\"\") print \$1; }' | " . distDir("make-trampolines"))
                        ->stdout($tempDir, 'trampolines.h')->run();
                  shell("cat '$tramp' | awk -F '\t' '{if (\$2!=\"\") print \$2; }'")
                        ->stdout($tempDir, 'used_symbols')->run(); 
                  shell("(cat '$tramp' | awk -F '\t' '{if (\$1!=\"\") print \"__\" \$1; }'; comm -12 '" . catfile($tempDir, 'used_symbols') . "' '" . dumpSymbols() . "') | sort | uniq | " . distDir("make-symbols"))
                        ->stdout($tempDir, 'symbols.c')->run();
                  shell($compiler, '-fsanitize=undefined', '-o', catfile($tempDir, 'native_binary'),
                              catfile($dir, 'main.o'),
                              catfile($dir, 'platform.o'),
                              catfile($dir, 'server.c'),
                              '-I', $dir, '-I', $tempDir, "-w", "-g",
                              ldArgs())->run();
            } else {
                  shell('touch', catfile($tempDir, 'native_binary'))->run();
            }

            my $old_cwd = getcwd();
            chdir($tempDir);
            shell('ld', '-r', '-b', 'binary', '-o', 'kore_term.o', 'kore_term')->run();
            shell('ld', '-r', '-b', 'binary', '-o', 'marshal_term.o', 'marshal_term')->run();
            shell('ld', '-r', '-b', 'binary', '-o', 'plugin_path.o', 'plugin_path')->run();
            shell('ld', '-r', '-b', 'binary', '-o', 'native_binary.o', 'native_binary')->run();
            chdir($old_cwd);

            shell($compiler, catfile($dir, 'execution_partial.o'), '-o', $oval, '-Wl,-E',
                        catfile($tempDir, 'kore_term.o'),
                        catfile($tempDir, 'marshal_term.o'),
                        catfile($tempDir, 'plugin_path.o'),
                        catfile($tempDir, 'native_binary.o'),
                        ldArgs())->run();
      }

      return 0;
}

sub mergeObjs {
      my (@srcFiles) = @_;

      while (scalar @srcFiles > 0) {
            my $oval = tempFile('merge');
            my $input = shift @srcFiles;
            my $lang = shift @srcFiles;
            compile($oval, $input, $lang);
            classify($oval, 'none');
      }

      my $trampolines = tempFile('trampolines');
      my @trampolineFiles = trampolineFiles();
      shell("cat @trampolineFiles | sort | uniq")->stdout($trampolines)->run();

      return $trampolines;
}

sub compile {
      my ($oval, $inputFile, $lang) = @_;
      my $compiler = 'gcc';
      if ($lang eq 'c' or $lang eq 'c++') {
            my $kast = tempFile('kast');
            my $obj = tempFile('obj');
            my $trampolines = tempFile('trampolines');
            my $uuid = create_uuid_as_string();
            shell(getKRunCommand($kast, [], $inputFile, 0, $lang, $uuid, $trampolines))->verbose()->run();
            if (arg('-Xk++')) {
                  $compiler = 'g++';
            }
            if (arg('-fno-native-compilation')) {
                  shell($compiler, '-c', getStd($lang), '-x', $lang, '/dev/null', '-o', $obj)->verbose()->run();
            } else {
                  setShellDebugFile($obj, 0);
                  shell($compiler, '-c', getStd($lang), '-x', $lang, $inputFile, '-o', $obj, cppArgs())->verbose()->run();
                  shell(distDir('globalize-syms'), $uuid, $obj)->run();
            }
            shell('objcopy', '--redefine-sym', 'main=' . RVMAIN, $obj)->run();
            shell(distDir('merge-kcc-obj'), $obj, $kast, $trampolines, $oval)->run();
      } else {
            setShellDebugFile($oval, 0);
            shell($compiler, '-c', '-x', $lang, $inputFile, '-o', $oval, cppArgs())->verbose()->run();
      }
}

sub pushObj {
      my ($arr, $obj, $i) = @_;

      if (defined $obj) {
            push(@{$_[0]}, "-pOBJ$i=cat");
            push(@{$_[0]}, "-cOBJ$i=$obj");
      } else {
            push(@{$_[0]}, "-pOBJ$i=" . PRINTF);
            push(@{$_[0]}, "-cOBJ$i=.K");
      }
}

sub initOptions {
      my @options = ();
      if (arg('-fno-native-compilation')) {
            push(@options, "`NoNativeFallback`(.KList)");
      }
      if (arg('-frecover-all-errors')) {
            push(@options, "`RecoverAll`(.KList)");
      }
      if (arg('-fuse-native-std-lib')) {
            push(@options, "`UseNativeStdLib`(.KList)");
      }
      if (arg('-flint') || arg('-Wlint')) {
            push(@options, "`Lint`(.KList)");
      }
      @options
}

sub addArg {
      my ($name, $value, $category, @krunArgs) = @_;

      if (useInterpreter()) {
            push(@krunArgs, '-c', $name, $value, $category);
      } else {
            push(@krunArgs, "-c$name=$value");
            if ($category eq 'text' or $category eq 'binary') {
                  push(@krunArgs, "-p$name=" . PRINTF);
            } else {
                  push(@krunArgs, "-p$name=cat");
            }
      }
      return @krunArgs;
}

sub getKRunCommand {
      my ($output, $objFiles, $src, $link, $lang, $uuid, $trampolines) = @_;

      my $cTransDef = profileDir("c11-translation-kompiled");
      my $cppTransDef = profileDir("cpp14-translation-kompiled");

      my @krunArgs;
      my $symbols = $link ? dumpSymbols() : 'dummy';
      if (useInterpreter()) {
            my $dir = $lang eq 'c++' ? catfile($cppTransDef, 'cpp14-translation-kompiled') : catfile($cTransDef, 'c11-translation-kompiled');
            @krunArgs =
                  ( catfile($dir, 'interpreter')
                  , catfile($dir, 'realdef.cma')
                  , $symbols
                  , '--output-file', $output
                  );
      } else {
            @krunArgs =
                  ( KRUN
                  , '--output', 'binary'
                  , '--output-file', $output
                  , '-d', $lang eq 'c++' ? $cppTransDef : $cTransDef
                  , '-w', 'none'
                  , '--smt', 'none'
                  , '--argv', $symbols
                  );

            if (arg('-d')) {
                  push(@krunArgs, '--debug');
            }
      }

      if (arg('-ftranslation-depth=')) {
            push(@krunArgs, '--depth');
            push(@krunArgs, arg('-ftranslation-depth='));
      }

      my @options = initOptions();
      state $hasBuiltins = 0;
      if (!$hasBuiltins && arg('-Xbuiltins')) {
            push(@options, "`XBuiltins`(.KList)");
            $hasBuiltins = 1;
      }
      if (!$link) {
            push(@options, "`NoLink`(.KList)");
      }

      my $opts = makeSet(@options);
      my ($rvErrorJson, $string) = (getRVErrorJson(), QUOTE_STRING);
      my $json = "#token($rvErrorJson, $string)";

      @krunArgs = addArg("OPTIONS", $opts, 'text', @krunArgs);
      @krunArgs = addArg("JSON", $json, 'text', @krunArgs);

      if (!defined $uuid) {
            $uuid = create_uuid_as_string();
      }
      my $encodedUuid = quote(backslash(quote($uuid)));
      my $uuidOpt = "#token($encodedUuid, $string)";
      @krunArgs = addArg("UUID", $uuidOpt, 'text', @krunArgs);

      if (scalar @{$objFiles}) {
            my $allObjsFile = tempFile('all-objs');
            my @catArgs = ();
            my @objTexts = ();
            for (my $i = 0; $i < scalar @{$objFiles}; $i++) {
                  my $thisObj = "";
                  if (-e $objFiles->[$i]) {
                        $thisObj = do {
                              local $/ = undef;
                              open my $fh, '<', $objFiles->[$i];
                              <$fh>;
                        };
                  }
                  if (length $thisObj) {
                        # push(@objTexts, "`unwrapObj`($thisObj)");
                        $thisObj = substr($thisObj, 8, -1);
                        # wrap $thisObj with `unwrapObj`()
                        push(@objTexts, "$thisObj\x02\x00\x00\x00\x00\x00\x00\x00\x09\x00u\x00n\x00w\x00r\x00a\x00p\x00O\x00b\x00j\x00\x00\x00\x00\x01");
                  }
            }
            my $objText = join('', @objTexts);
            my $one = chr((scalar @objTexts >> 24) & 0xff);
            my $two = chr((scalar @objTexts >> 16) & 0xff);
            my $three = chr((scalar @objTexts >> 8) & 0xff);
            my $four = chr((scalar @objTexts >> 0) & 0xff);
            $objText = MAGIC . "\x04\x00\x01$objText\x03$one$two$three$four\x07";
            open(my $file, '>', "$allObjsFile");
            print $file $objText;
            close $file;

            @krunArgs = addArg("OBJS", $allObjsFile, 'binaryfile', @krunArgs);
      } else {
            @krunArgs = addArg("OBJS", ".K", 'text', @krunArgs);
      }
      if (defined $src) {
            my $kast = parse($src, $lang, $trampolines);
            @krunArgs = addArg("PGM", $kast, 'textfile', @krunArgs);
      } else {
            @krunArgs = addArg("PGM", ".K", 'text', @krunArgs);
      }

      setShellDebugFile($output, 1);
      return @krunArgs;
}

sub dumpSymbols {
      state $syms = do {
            my $tmp = tempFile('syms');
            shell(distDir('gccsymdump'), ldArgs())->stdout($tmp)->run();
            rel2abs($tmp);
      };
      return $syms;
}

sub preprocess {
      my ($output, $trampolines, $inputFile, $lang) = @_;
      my $isStdout = 0;
      if ($output eq '-') {
            $output = tempFile('pp');
            $isStdout = 1;
      }
      my $directoryname = dirname($inputFile);

      my @ppArgs;
      if ($lang eq 'c++') {
            @ppArgs = (profileDir('cpp-pp'), cppArgs(), getStd($lang), $inputFile, '-o', $output);
      } else {
            @ppArgs = (profileDir('pp'), cppArgs(), getStd($lang), $inputFile, '-o', $output);
      }

      setShellDebugFile($output, 0);
      my $retval = shell(@ppArgs)->verbose()->result();
      if (!$retval) {
            if (arg('-fnative-binary')) {
                  my $cmd = "set -o pipefail && " . distDir("call-sites") . " '$output' --char=sc -- -x $lang | sort | uniq";
                  shell('/bin/bash', '-c', $cmd)->stdout($trampolines)->run();
            } else {
                  shell("touch $trampolines")->run();
            }
            shell("rv-ifdefclear $output")->run();
            for (ifdefs()) {
                  shell("rv-ifdefall $output @$_")->run();
            }
            if ($isStdout) {
                  shell("cat $output")->verbose()->run();
            }
      }
      return $retval;
}

sub parse {
      my ($inputFile, $lang, $trampolines) = @_;

      my $ppResult = tempFile('pp');
      my $kast = tempFile('kast');
      setShellDebugFile($ppResult, 0);
      checkError(preprocess($ppResult, $trampolines, $inputFile, $lang));

      setShellDebugFile($kast, 0);
      if ($lang eq 'c++') {
            my $std = getStd('c++');
            my $cppparser = distDir('clang-kast');
            shell($cppparser, $ppResult, '--', '-x', 'c++-cpp-output', $std)->verbose()->stdout($kast)->run();

            return $kast;
      }
      my $cparser = distDir('cparser');
      shell($cparser, $ppResult, '--trueName', $inputFile)->verbose()->stdout($kast)->run();

      return $kast;
}

sub getStd {
      my ($lang) = @_;

      my $std;
      if (defined arg('-std=')) {
            $std = arg('-std=');
      } elsif ($lang eq 'c++') {
            $std = 'c++14';
      } elsif ($lang eq 'c') {
            $std = 'c11';
      } else {
            return '';
      }
      return "-std=$std";
}

sub makeSet {
      my $set = '`.Set`(.KList)';
      foreach my $el (@_) {
            $set = "`_Set_`(`SetItem`($el), $set)";
      }
      return $set;
}

sub useInterpreter {
      -e profileDir('cpp14-translation-kompiled', 'cpp14-translation-kompiled', 'interpreter');
}

sub getRVErrorJson {
      state $json = do {
            my $format;
            my $output;
            if (arg('-fissue-report=')) {
                  my $file = arg('-fissue-report=');
                  my ($base, $dir, $ext) = fileparse($file, ('\.json', '\.JSON', '\.csv', '\.CSV'));
                  if (!$ext) {
                        error("Format not supported for the issue report file '$file'.\nThe format for the issue report (JSON/CSV) is inferred from the file extension.\n");
                  }
                  $format = uc substr($ext,1);
                  $output = quote(backslash(abs_path($file)));
                  $output = ", \"output\": $output";
            } else {
                  $format = "Console";
                  $output = "";
            }

            my $allSuppress = join(',', suppressions());
            my $rvError = shell('command -v rv-error || true')->stdout()->run();
            chop($rvError);
            $rvError = quote(backslash($rvError));

            my $messageLength = 80;
            if (arg('-fmessage-length=')) {
                  $messageLength = arg('-fmessage-length=');
            }

            quote(backslash(quote(backslash
                  ( "{\"suppressions\": [$allSuppress]"
                  . ",\"message_length\": $messageLength"
                  . ",\"format\": \"$format\""
                  . ",\"previous_errors\": []"
                  . ",\"fatal_errors\": " . (arg('-Wfatal-errors')? 'true' : 'false')
                  . ",\"rv_error\": $rvError"
                  . "$output}"
                  ))));
      };
      return $json;
}

sub interruptHandler {
      # Call single cleanup point.
      finalCleanup();
      # Since we were interrupted, we should exit with a non-zero code.
      exit 1;
}

# This subroutine can be used as a way to ensure we clean up all resources
# whenever we exit. This is going to be mostly temp files. If the program
# terminates for almost any reason, this code will be executed.
sub finalCleanup { }

sub error {
      print STDERR @_;
      exit 1;
}

# This block gets run at the end of a normally terminating program, whether it
# simply exits, or dies. We use this to clean up.
END {
      # $? contains the value the program would normally have exited with.
      my $retval = $?;
      # Call single cleanup point.
      finalCleanup();
      exit $retval;
}

