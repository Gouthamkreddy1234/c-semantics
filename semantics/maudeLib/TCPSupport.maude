--- syntax used by the tcp interface and the tcp backend
mod TCP-SYNTAX-BUILTIN-MODULE is
	including SOCKET-BUILTIN-MODULE .
	
	op error : -> String .
	op containedRequest : Configuration -> [String] .
	op toSend : String -> Msg .
	op start : Nat -> Configuration .
	op tcpRequest : String -> [String] .
	op errorTCPSyntax : -> String .
endm

mod TCP-CLIENT-BUILTIN-MODULE is
	including TCP-SYNTAX-BUILTIN-MODULE .
	
	sort TCPState .
		
	op Client : -> Cid .
	op cnum : Nat -> Oid .
	
	ops idle connecting sending receiving haveAnswer closing connected finished : -> TCPState [ctor] .
	
	op state:_ : TCPState -> Attribute [ctor] .
	op answer:_ : String -> Attribute [ctor] .
	op connectedTo:_ : Oid -> Attribute [ctor] .
	
		
	vars Me Server : Oid .
	var A : AttributeSet .
	var S : String .
	var M : Msg .
	var C : Configuration .
	var N : Nat .
	
	rl < Me : Client | state: connecting, A > createdSocket(Me, socketManager, Server)
	=> < Me : Client | state: connected, connectedTo: Server, A >
	[print "connected"] .
	
	----- errors
	eq containedRequest(C socketError(Me, socketManager, S))
	= error
	[print "socket error: " S] .
	eq containedRequest(C < Me : Client | state: connecting, A > closedSocket(Me, Server, S))
	= error
	[print "error connecting: " S] .
	eq containedRequest(C < Me : Client | state: receiving, A > closedSocket(Me, Server, S))
	= error
	[print "error receiving: " S] .
	-----
	
	rl < Me : Client | state: connected, connectedTo: Server, A > toSend(S)
	=> < Me : Client | state: sending, connectedTo: Server, A > send(Server, Me, S)
	[print "sending"] .
	
	rl < Me : Client | state: sending, A > sent(Me, Server)
	=> < Me : Client | state: receiving, A > receive(Server, Me)
	[print "receiving"] .
	
	rl < Me : Client | state: receiving, A > received(Me, Server, S)
	=> < Me : Client | state: haveAnswer, answer: S, A >
	[print "have answer"] .
	
	rl < Me : Client | state: haveAnswer, connectedTo: Server, A > 
	=> < Me : Client | state: closing, connectedTo: Server, A > closeSocket(Server, Me)
	[print "closing"] .
	
	rl < Me : Client | state: closing, A  > closedSocket(Me, Server, S)
	=> < Me : Client | state: finished, A  >
	[print "finished"] .
	
	rl containedRequest(C < Me : Client | state: finished, answer: S, A  >)
	=> S
	[print "popping out of socket stuff"] .
	
	rl start(N) => 
		<>
		< cnum(N) : Client | state: connecting >
		createClientTcpSocket(socketManager, cnum(N), "localhost", 7077) .
endm

mod TCP-INTERFACE-BUILTIN-MODULE is
	including TCP-SYNTAX-BUILTIN-MODULE .
	including TCP-CLIENT-BUILTIN-MODULE .
	including PL-COUNTER .
		
	rl tcpRequest(S:String) => containedRequest(start(counter) toSend(S:String +String "###EOMTCP###" +String "\r\n")) .
	
	op readFile : String -> String .
	op writeFile : String -> String .
	op check : String -> String .
	
	eq readFile(S:String) = check(tcpRequest("###READFILE###" +String S:String)) .
	eq writeFile(S:String) = check(tcpRequest("###WRITEFILE###" +String S:String)) .
			
	ceq check(S:String) = substrString(S:String, lengthString("###SUCC###"), lengthString(S:String))
		if substrString(S:String, 0, lengthString("###SUCC###")) ==Bool "###SUCC###" .
		
	ceq check(S:String) = errorTCPSyntax
		if substrString(S:String, 0, lengthString("###ERR###")) ==Bool "###ERR###" .
		
	--- ceq check(S:String) = errorTCPSyntax
		--- if substrString(S:String, 0, 0) =/=Bool "" .

	
endm
