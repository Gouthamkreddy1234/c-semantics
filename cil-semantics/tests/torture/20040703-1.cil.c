/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned int cpp_num_part;
struct cpp_num;
typedef struct cpp_num cpp_num;
struct cpp_num {
   cpp_num_part high ;
   cpp_num_part low ;
   int unsignedp ;
   int overflow ;
};
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void)  __attribute__((__leaf__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status )  __attribute__((__leaf__)) ;
static int num_positive(cpp_num num , unsigned int precision ) 
{ 

  {
  if ((unsigned long )precision > sizeof(cpp_num_part ) * 8UL) {
    precision = (unsigned int )((unsigned long )precision - sizeof(cpp_num_part ) * 8UL);
    return ((num.high & (1U << (precision - 1U))) == 0U);
  }
  return ((num.low & (1U << (precision - 1U))) == 0U);
}
}
static cpp_num num_trim(cpp_num num , unsigned int precision ) 
{ 

  {
  if ((unsigned long )precision > sizeof(cpp_num_part ) * 8UL) {
    precision = (unsigned int )((unsigned long )precision - sizeof(cpp_num_part ) * 8UL);
    if ((unsigned long )precision < sizeof(cpp_num_part ) * 8UL) {
      num.high &= (1U << precision) - 1U;
    }
  } else {
    if ((unsigned long )precision < sizeof(cpp_num_part ) * 8UL) {
      num.low &= (1U << precision) - 1U;
    }
    num.high = 0U;
  }
  return (num);
}
}
static cpp_num num_rshift(cpp_num num , unsigned int precision , unsigned int n ) 
{ cpp_num_part sign_mask ;
  int x ;
  int tmp ;

  {
  tmp = num_positive(num, precision);
  x = tmp;
  if (num.unsignedp) {
    sign_mask = 0U;
  } else {
    if (x) {
      sign_mask = 0U;
    } else {
      sign_mask = ~ 0U;
    }
  }
  if (n >= precision) {
    num.low = sign_mask;
    num.high = num.low;
  } else {
    if ((unsigned long )precision < sizeof(cpp_num_part ) * 8UL) {
      num.high = sign_mask;
      num.low |= sign_mask << precision;
    } else {
      if ((unsigned long )precision < 2UL * (sizeof(cpp_num_part ) * 8UL)) {
        num.high |= sign_mask << ((unsigned long )precision - sizeof(cpp_num_part ) * 8UL);
      }
    }
    if ((unsigned long )n >= sizeof(cpp_num_part ) * 8UL) {
      n = (unsigned int )((unsigned long )n - sizeof(cpp_num_part ) * 8UL);
      num.low = num.high;
      num.high = sign_mask;
    }
    if (n) {
      num.low = (num.low >> n) | (num.high << (sizeof(cpp_num_part ) * 8UL - (unsigned long )n));
      num.high = (num.high >> n) | (sign_mask << (sizeof(cpp_num_part ) * 8UL - (unsigned long )n));
    }
  }
  num = num_trim(num, precision);
  num.overflow = 0;
  return (num);
}
}
cpp_num num_lshift(cpp_num num , unsigned int precision , unsigned int n ) 
{ int tmp ;
  cpp_num orig ;
  unsigned int m ;
  cpp_num maybe_orig ;
  cpp_num tmp___0 ;
  int tmp___1 ;

  {
  if (n >= precision) {
    if (! num.unsignedp) {
      if (! ((num.low | num.high) == 0U)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    num.overflow = tmp;
    num.low = 0U;
    num.high = num.low;
  } else {
    m = n;
    orig = num;
    if ((unsigned long )m >= sizeof(cpp_num_part ) * 8UL) {
      m = (unsigned int )((unsigned long )m - sizeof(cpp_num_part ) * 8UL);
      num.high = num.low;
      num.low = 0U;
    }
    if (m) {
      num.high = (num.high << m) | (num.low >> (sizeof(cpp_num_part ) * 8UL - (unsigned long )m));
      num.low <<= m;
    }
    num = num_trim(num, precision);
    if (num.unsignedp) {
      num.overflow = 0;
    } else {
      tmp___0 = num_rshift(num, precision, n);
      maybe_orig = tmp___0;
      if (orig.low == maybe_orig.low) {
        if (orig.high == maybe_orig.high) {
          tmp___1 = 0;
        } else {
          tmp___1 = 1;
        }
      } else {
        tmp___1 = 1;
      }
      num.overflow = tmp___1;
    }
  }
  return (num);
}
}
unsigned int precision  =    64U;
unsigned int n  =    16U;
cpp_num num  =    {(cpp_num_part )0, (cpp_num_part )3, 0, 0};
int main(void) 
{ cpp_num res ;
  cpp_num tmp ;

  {
  tmp = num_lshift(num, 64U, n);
  res = tmp;
  if (res.low != 196608U) {
    abort();
  }
  if (res.high != 0U) {
    abort();
  }
  if (res.overflow != 0) {
    abort();
  }
  exit(0);
}
}
