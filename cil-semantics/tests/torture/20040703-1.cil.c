/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 6 "20040703-1.c"
typedef unsigned int cpp_num_part;
#line 7
struct cpp_num;
#line 7 "20040703-1.c"
typedef struct cpp_num cpp_num;
#line 8 "20040703-1.c"
struct cpp_num {
   cpp_num_part high ;
   cpp_num_part low ;
   int unsignedp ;
   int overflow ;
};
#line 17 "../../lib/includes/stdlib.h"
extern void exit(int status ) ;
#line 21
extern void abort(void) ;
#line 16 "20040703-1.c"
static int num_positive(cpp_num num , unsigned int precision ) 
{ 

  {
#line 19
  if ((unsigned long )precision > sizeof(cpp_num_part ) * 8UL) {
#line 21
    precision = (unsigned int )((unsigned long )precision - sizeof(cpp_num_part ) * 8UL);
#line 22
    return ((num.high & (1U << (precision - 1U))) == 0U);
  }
#line 25
  return ((num.low & (1U << (precision - 1U))) == 0U);
}
}
#line 28 "20040703-1.c"
static cpp_num num_trim(cpp_num num , unsigned int precision ) 
{ 

  {
#line 31
  if ((unsigned long )precision > sizeof(cpp_num_part ) * 8UL) {
#line 33
    precision = (unsigned int )((unsigned long )precision - sizeof(cpp_num_part ) * 8UL);
#line 34
    if ((unsigned long )precision < sizeof(cpp_num_part ) * 8UL) {
#line 35
      num.high &= (1U << precision) - 1U;
    }
  } else {
#line 39
    if ((unsigned long )precision < sizeof(cpp_num_part ) * 8UL) {
#line 40
      num.low &= (1U << precision) - 1U;
    }
#line 41
    num.high = 0U;
  }
#line 44
  return (num);
}
}
#line 48 "20040703-1.c"
static cpp_num num_rshift(cpp_num num , unsigned int precision , unsigned int n ) 
{ cpp_num_part sign_mask ;
  int x ;
  int tmp ;

  {
#line 52
  tmp = num_positive(num, precision);
#line 52
  x = tmp;
#line 54
  if (num.unsignedp) {
#line 55
    sign_mask = 0U;
  } else {
#line 54
    if (x) {
#line 55
      sign_mask = 0U;
    } else {
#line 57
      sign_mask = ~ 0U;
    }
  }
#line 59
  if (n >= precision) {
#line 60
    num.low = sign_mask;
#line 60
    num.high = num.low;
  } else {
#line 64
    if ((unsigned long )precision < sizeof(cpp_num_part ) * 8UL) {
#line 65
      num.high = sign_mask;
#line 65
      num.low |= sign_mask << precision;
    } else {
#line 66
      if ((unsigned long )precision < 2UL * (sizeof(cpp_num_part ) * 8UL)) {
#line 67
        num.high |= sign_mask << ((unsigned long )precision - sizeof(cpp_num_part ) * 8UL);
      }
    }
#line 69
    if ((unsigned long )n >= sizeof(cpp_num_part ) * 8UL) {
#line 71
      n = (unsigned int )((unsigned long )n - sizeof(cpp_num_part ) * 8UL);
#line 72
      num.low = num.high;
#line 73
      num.high = sign_mask;
    }
#line 76
    if (n) {
#line 78
      num.low = (num.low >> n) | (num.high << (sizeof(cpp_num_part ) * 8UL - (unsigned long )n));
#line 79
      num.high = (num.high >> n) | (sign_mask << (sizeof(cpp_num_part ) * 8UL - (unsigned long )n));
    }
  }
#line 83
  num = num_trim(num, precision);
#line 84
  num.overflow = 0;
#line 85
  return (num);
}
}
#line 90 "20040703-1.c"
cpp_num num_lshift(cpp_num num , unsigned int precision , unsigned int n ) 
{ int tmp ;
  cpp_num orig ;
  unsigned int m ;
  cpp_num maybe_orig ;
  cpp_num tmp___0 ;
  int tmp___1 ;

  {
#line 93
  if (n >= precision) {
#line 95
    if (! num.unsignedp) {
#line 95
      if (! ((num.low | num.high) == 0U)) {
#line 95
        tmp = 1;
      } else {
#line 95
        tmp = 0;
      }
    } else {
#line 95
      tmp = 0;
    }
#line 95
    num.overflow = tmp;
#line 96
    num.low = 0U;
#line 96
    num.high = num.low;
  } else {
#line 101
    m = n;
#line 103
    orig = num;
#line 104
    if ((unsigned long )m >= sizeof(cpp_num_part ) * 8UL) {
#line 106
      m = (unsigned int )((unsigned long )m - sizeof(cpp_num_part ) * 8UL);
#line 107
      num.high = num.low;
#line 108
      num.low = 0U;
    }
#line 110
    if (m) {
#line 112
      num.high = (num.high << m) | (num.low >> (sizeof(cpp_num_part ) * 8UL - (unsigned long )m));
#line 113
      num.low <<= m;
    }
#line 115
    num = num_trim(num, precision);
#line 117
    if (num.unsignedp) {
#line 118
      num.overflow = 0;
    } else {
#line 121
      tmp___0 = num_rshift(num, precision, n);
#line 121
      maybe_orig = tmp___0;
#line 122
      if (orig.low == maybe_orig.low) {
#line 122
        if (orig.high == maybe_orig.high) {
#line 122
          tmp___1 = 0;
        } else {
#line 122
          tmp___1 = 1;
        }
      } else {
#line 122
        tmp___1 = 1;
      }
#line 122
      num.overflow = tmp___1;
    }
  }
#line 126
  return (num);
}
}
#line 129 "20040703-1.c"
unsigned int precision  =    64U;
#line 130 "20040703-1.c"
unsigned int n  =    16U;
#line 132 "20040703-1.c"
cpp_num num  =    {(cpp_num_part )0, (cpp_num_part )3, 0, 0};
#line 134 "20040703-1.c"
int main(void) 
{ cpp_num res ;
  cpp_num tmp ;

  {
#line 136
  tmp = num_lshift(num, 64U, n);
#line 136
  res = tmp;
#line 138
  if (res.low != 196608U) {
#line 139
    abort();
  }
#line 141
  if (res.high != 0U) {
#line 142
    abort();
  }
#line 144
  if (res.overflow != 0) {
#line 145
    abort();
  }
#line 147
  exit(0);
}
}
