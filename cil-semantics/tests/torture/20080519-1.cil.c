/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long HARD_REG_SET[2];
struct du_chain {
   struct du_chain *next_use ;
   int cl ;
};
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void)  __attribute__((__leaf__)) ;
HARD_REG_SET reg_class_contents[2]  ;
void ( __attribute__((__noinline__)) merge_overlapping_regs)(HARD_REG_SET *p ) 
{ 

  {
  if ((*p)[0] != 0xffffffffUL) {
    abort();
  } else {
    if ((*p)[1] != 0xffffffffUL) {
      abort();
    }
  }
  return;
}
}
void ( __attribute__((__noinline__)) regrename_optimize)(struct du_chain *this ) 
{ HARD_REG_SET this_unavailable ;
  unsigned long *scan_fp_ ;
  int n_uses ;
  struct du_chain *last ;

  {
  this_unavailable[0] = 0UL;
  this_unavailable[1] = 0UL;
  n_uses = 0;
  last = this;
  while (last->next_use) {
    scan_fp_ = reg_class_contents[last->cl];
    n_uses ++;
    this_unavailable[0] |= ~ *(scan_fp_ + 0);
    this_unavailable[1] |= ~ *(scan_fp_ + 1);
    last = last->next_use;
  }
  if (n_uses < 1) {
    return;
  }
  scan_fp_ = reg_class_contents[last->cl];
  this_unavailable[0] |= ~ *(scan_fp_ + 0);
  this_unavailable[1] |= ~ *(scan_fp_ + 1);
  merge_overlapping_regs(& this_unavailable);
  return;
}
}
int main(void) 
{ struct du_chain du1 ;
  struct du_chain du0 ;

  {
  du1.next_use = (struct du_chain *)0;
  du1.cl = 0;
  du0.next_use = & du1;
  du0.cl = 1;
  reg_class_contents[0][0] = 0xffffffffUL;
  reg_class_contents[0][1] = 0xffffffffUL;
  reg_class_contents[1][0] = 0UL;
  reg_class_contents[1][1] = 0UL;
  regrename_optimize(& du0);
  return (0);
}
}
