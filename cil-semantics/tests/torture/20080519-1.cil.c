/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 4 "20080519-1.c"
typedef unsigned long HARD_REG_SET[2];
#line 7 "20080519-1.c"
struct du_chain {
   struct du_chain *next_use ;
   int cl ;
};
#line 21 "../../lib/includes/stdlib.h"
extern void abort(void) ;
#line 5 "20080519-1.c"
HARD_REG_SET reg_class_contents[2]  ;
#line 13 "20080519-1.c"
void ( __attribute__((__noinline__)) merge_overlapping_regs)(HARD_REG_SET *p ) 
{ 

  {
#line 16
  if ((*p)[0] != 0xffffffffUL) {
#line 17
    abort();
  } else {
#line 16
    if ((*p)[1] != 0xffffffffUL) {
#line 17
      abort();
    }
  }
#line 18
  return;
}
}
#line 20 "20080519-1.c"
void ( __attribute__((__noinline__)) regrename_optimize)(struct du_chain *this ) 
{ HARD_REG_SET this_unavailable ;
  unsigned long *scan_fp_ ;
  int n_uses ;
  struct du_chain *last ;

  {
#line 28
  this_unavailable[0] = 0UL;
#line 29
  this_unavailable[1] = 0UL;
#line 31
  n_uses = 0;
#line 32
  last = this;
#line 32
  while (last->next_use) {
#line 34
    scan_fp_ = reg_class_contents[last->cl];
#line 35
    n_uses ++;
#line 36
    this_unavailable[0] |= ~ *(scan_fp_ + 0);
#line 37
    this_unavailable[1] |= ~ *(scan_fp_ + 1);
#line 32
    last = last->next_use;
  }
#line 39
  if (n_uses < 1) {
#line 40
    return;
  }
#line 42
  scan_fp_ = reg_class_contents[last->cl];
#line 43
  this_unavailable[0] |= ~ *(scan_fp_ + 0);
#line 44
  this_unavailable[1] |= ~ *(scan_fp_ + 1);
#line 46
  merge_overlapping_regs(& this_unavailable);
#line 47
  return;
}
}
#line 49 "20080519-1.c"
int main(void) 
{ struct du_chain du1 ;
  struct du_chain du0 ;

  {
#line 51
  du1.next_use = (struct du_chain *)0;
#line 51
  du1.cl = 0;
#line 52
  du0.next_use = & du1;
#line 52
  du0.cl = 1;
#line 53
  reg_class_contents[0][0] = 0xffffffffUL;
#line 54
  reg_class_contents[0][1] = 0xffffffffUL;
#line 55
  reg_class_contents[1][0] = 0UL;
#line 56
  reg_class_contents[1][1] = 0UL;
#line 57
  regrename_optimize(& du0);
#line 58
  return (0);
}
}
