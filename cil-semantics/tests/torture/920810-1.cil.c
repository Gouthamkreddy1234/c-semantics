/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
struct __anonstruct_t_25 {
   void *super ;
   int name ;
   int size ;
};
typedef struct __anonstruct_t_25 t;
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2),
__leaf__)) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1),
__leaf__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__,
__leaf__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void)  __attribute__((__leaf__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status )  __attribute__((__leaf__)) ;
t *f(t *clas , int size ) 
{ t *child ;
  void *tmp ;

  {
  tmp = malloc((unsigned long )size);
  child = (t *)tmp;
  memcpy((void * __restrict  )child, (void const   * __restrict  )clas, (unsigned long )clas->size);
  child->super = (void *)clas;
  child->name = 0;
  child->size = size;
  return (child);
}
}
int main(void) 
{ t foo ;
  t *bar ;

  {
  memset((void *)(& foo), 37, sizeof(t ));
  foo.size = (int )sizeof(t );
  bar = f(& foo, (int )sizeof(t ));
  if ((unsigned long )bar->super != (unsigned long )(& foo)) {
    abort();
  } else {
    if (bar->name != 0) {
      abort();
    } else {
      if ((unsigned long )bar->size != sizeof(t )) {
        abort();
      }
    }
  }
  exit(0);
}
}
