/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef long long bfd_signed_vma;
typedef bfd_signed_vma file_ptr;
enum bfd_boolean {
    false = 0,
    true = 1
} ;
typedef enum bfd_boolean boolean;
typedef unsigned long long bfd_size_type;
typedef unsigned int flagword;
typedef unsigned long long CORE_ADDR;
typedef unsigned long long bfd_vma;
struct bfd_struct {
   int x ;
};
struct asection_struct {
   unsigned int user_set_vma : 1 ;
   bfd_vma vma ;
   bfd_vma lma ;
   unsigned int alignment_power ;
   unsigned int entsize ;
};
typedef struct bfd_struct bfd;
typedef struct asection_struct asection;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void)  __attribute__((__leaf__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status )  __attribute__((__leaf__)) ;
static bfd *bfd_openw_with_cleanup(char *filename , char const   *target , char *mode ) ;
static asection *bfd_make_section_anyway(bfd *abfd , char const   *name ) ;
static boolean bfd_set_section_size(bfd *abfd , asection *sec , bfd_size_type val ) ;
static boolean bfd_set_section_flags(bfd *abfd , asection *sec , flagword flags ) ;
static boolean bfd_set_section_contents(bfd *abfd , asection *section , void *data ,
                                        file_ptr offset , bfd_size_type count ) ;
static void dump_bfd_file(char *filename , char *mode , char *target , CORE_ADDR vaddr ,
                          char *buf , int len ) 
{ bfd *obfd ;
  asection *osection ;
  bfd_vma tmp ;

  {
  obfd = bfd_openw_with_cleanup(filename, (char const   *)target, mode);
  osection = bfd_make_section_anyway(obfd, ".newsec");
  bfd_set_section_size(obfd, osection, (unsigned long long )len);
  tmp = vaddr;
  osection->lma = tmp;
  osection->vma = tmp;
  osection->user_set_vma = (unsigned int )((enum bfd_boolean )1);
  osection->alignment_power = 0U;
  bfd_set_section_flags(obfd, osection, 515U);
  osection->entsize = 0U;
  bfd_set_section_contents(obfd, osection, (void *)buf, 0LL, (unsigned long long )len);
  return;
}
}
static bfd *bfd_openw_with_cleanup(char *filename , char const   *target , char *mode ) ;
static bfd foo_bfd  =    {0};
static bfd *bfd_openw_with_cleanup(char *filename , char const   *target , char *mode ) 
{ 

  {
  return (& foo_bfd);
}
}
static asection *bfd_make_section_anyway(bfd *abfd , char const   *name ) ;
static asection foo_section  =    {0U, (bfd_vma )0, (bfd_vma )0, 0U, 0U};
static asection *bfd_make_section_anyway(bfd *abfd , char const   *name ) 
{ 

  {
  return (& foo_section);
}
}
static boolean bfd_set_section_size(bfd *abfd , asection *sec , bfd_size_type val ) 
{ 

  {
  return ((enum bfd_boolean )1);
}
}
static boolean bfd_set_section_flags(bfd *abfd , asection *sec , flagword flags ) 
{ 

  {
  return ((enum bfd_boolean )0);
}
}
static boolean bfd_set_section_contents(bfd *abfd , asection *section , void *data ,
                                        file_ptr offset , bfd_size_type count ) 
{ 

  {
  if (count != 514703087ULL) {
    abort();
  }
  return ((enum bfd_boolean )0);
}
}
static char hello[6]  = {      (char )'h',      (char )'e',      (char )'l',      (char )'l', 
        (char )'o',      (char )'\000'};
int main(void) 
{ 

  {
  dump_bfd_file((char *)0, (char *)0, (char *)0, 3735928559ULL, hello, 514703087);
  exit(0);
}
}
