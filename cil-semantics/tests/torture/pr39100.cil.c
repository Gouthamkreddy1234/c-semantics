/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

struct E {
   int p ;
   struct E *n ;
};
typedef struct E *EP;
struct C {
   EP x ;
   short cn ;
   short cp ;
};
typedef struct C *CP;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void)  __attribute__((__leaf__)) ;
CP ( __attribute__((__noinline__)) foo)(CP h , EP x ) 
{ EP pl ;
  EP *pa ;
  EP nl ;
  EP *na ;
  EP n ;

  {
  pl = (EP )0;
  pa = & pl;
  nl = (EP )0;
  na = & nl;
  while (x) {
    n = x->n;
    if ((x->p & 1) == 1) {
      h->cp = (short )((int )h->cp + 1);
      *pa = x;
      pa = & (*pa)->n;
    } else {
      h->cn = (short )((int )h->cn + 1);
      *na = x;
      na = & (*na)->n;
    }
    x = n;
  }
  *pa = nl;
  *na = (struct E *)0;
  h->x = pl;
  return (h);
}
}
int main(void) 
{ struct C c ;
  struct E e[2] ;

  {
  c.x = (EP )0;
  c.cn = (short)0;
  c.cp = (short)0;
  e[0].p = 0;
  e[0].n = & e[1];
  e[1].p = 1;
  e[1].n = (struct E *)0;
  foo(& c, & e[0]);
  if ((int )c.cn != 1) {
    abort();
  } else {
    if ((int )c.cp != 1) {
      abort();
    }
  }
  if ((unsigned long )c.x != (unsigned long )(& e[1])) {
    abort();
  }
  if ((unsigned long )e[1].n != (unsigned long )(& e[0])) {
    abort();
  }
  if (e[0].n) {
    abort();
  }
  return (0);
}
}
