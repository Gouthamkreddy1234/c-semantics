/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long long CORE_ADDR;
struct blockvector;
struct blockvector;
struct symtab {
   struct blockvector *blockvector ;
};
struct symbol {
   int len ;
   char *name ;
};
struct block {
   CORE_ADDR startaddr ;
   CORE_ADDR endaddr ;
   struct symbol *function ;
   struct block *superblock ;
   unsigned char gcc_compile_flag ;
   int nsyms ;
   struct symbol syms[1] ;
};
struct blockvector {
   int nblocks ;
   struct block *block[2] ;
};
struct blockvector *blockvector_for_pc_sect(CORE_ADDR pc , struct symtab *symtab ) 
{ register struct block *b ;
  register int bot ;
  register int top ;
  register int half ;
  struct blockvector *bl ;

  {
  bl = symtab->blockvector;
  b = bl->block[0];
  bot = 0;
  top = bl->nblocks;
  while (top - bot > 1) {
    half = ((top - bot) + 1) >> 1;
    b = bl->block[bot + half];
    if (b->startaddr <= pc) {
      bot += half;
    } else {
      top = bot + half;
    }
  }
  while (bot >= 0) {
    b = bl->block[bot];
    if (b->endaddr > pc) {
      return (bl);
    }
    bot --;
  }
  return ((struct blockvector *)0);
}
}
int main(void) 
{ struct block a ;
  struct block b ;
  struct blockvector bv ;
  struct symtab s ;
  struct blockvector *ret ;

  {
  a.startaddr = (CORE_ADDR )0;
  a.endaddr = (CORE_ADDR )65536;
  a.function = (struct symbol *)0;
  a.superblock = (struct block *)0;
  a.gcc_compile_flag = (unsigned char)1;
  a.nsyms = 20;
  a.syms[0].len = 0;
  a.syms[0].name = (char *)0;
  b.startaddr = (CORE_ADDR )65536;
  b.endaddr = (CORE_ADDR )131072;
  b.function = (struct symbol *)0;
  b.superblock = (struct block *)0;
  b.gcc_compile_flag = (unsigned char)1;
  b.nsyms = 20;
  b.syms[0].len = 0;
  b.syms[0].name = (char *)0;
  bv.nblocks = 2;
  bv.block[0] = & a;
  bv.block[1] = & b;
  s.blockvector = & bv;
  ret = blockvector_for_pc_sect(1280ULL, & s);
  return (0);
}
}
